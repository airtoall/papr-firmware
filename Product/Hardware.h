 // Hardware.h
 // 
 // This file defines all the hardware pins, and a bunch of hardware-specific functions for the Air One PAPR, PCB revision 3. 
 // This includes generic access to IO pins and timing, as well as definitions and functions specific to the PAPR- and/or the MCU,
 // such as configuring pins, initializing the hardware, and using the watchdog timer.
 // 
 // We intend to provide 2 different implementations of this API
 // - the product version, which runs on a PAPR board with MCU
 // - the unit test version, which runs on a PC and pretends to be a PAPR and MCU

#pragma once
#ifdef UNITTEST
#include "ArduinoDefs.h"
#else
#include "Arduino.h"
#include <avr/wdt.h> 
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// PCB Power Modes
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

// The PCB can run in either High Power mode or Low Power mode.
// - High Power Mode means that the PCB and MCU are fully powered 
// - Low Power Mode means that the MCU receives reduced voltage (approx 2.5 instead of 5)
//   and the rest of the PCB receives no power. In this mode, we must run the MCU at a
//   reduced clock speed (1 MHz instead of 8 MHz).
//
// The low power mode is intended for use when the PAPR is in the Power Off state. Im this state,
// you can use the MCU to check for button presses or charger activity, while consuming a negligible 
// amount of battery power.

enum PowerMode { lowPowerMode, fullPowerMode };

// On startup we are in low power mode: the low fuse byte causes the clock divider to be initialed to 2**3,
// and the PCB initializes itself to power off.


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Pin definitions and values
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

// Buttons
const int FAN_UP_PIN = 4;             // PD4   input   Digital: LOW = pushed, HIGH = released, requires pullup
const int FAN_DOWN_PIN = 9;           // PB1   input   Digital: LOW = pushed, HIGH = released, requires pullup
const int POWER_OFF_PIN = 8;          // PB0   input   Digital: LOW = pushed, HIGH = released, requires pullup
const int POWER_ON_PIN = 7;           // PD7   input   Digital: LOW = pushed, HIGH = released, requires pullup
const int BUTTON_PUSHED = LOW;        
const int BUTTON_RELEASED = HIGH;     
                                      
// Fan                                
const int FAN_PWM_PIN = 3;            // PD3   output  PWM generated by MCU's built-in PWM capabillity
const int FAN_RPM_PIN = 5;            // PD5   input   Digital: square wave coming from fan, firmware gets interrupt on each edge
const int FAN_ENABLE_PIN = 14;        // PB6   output  Digital: LOW = fan xxx, HIGH = fan xxx
const int FAN_OFF = HIGH;             // ?? TODO
const int FAN_ON = LOW;               // ?? TODO
                                      
// Power
const int BATTERY_VOLTAGE_PIN = A7;   // ADC7  input   10-bit ADC: convert to volts using VOLTS_PER_VOLTAGE_UNIT
const int CHARGE_CURRENT_PIN = A6;    // ADC6  input   10-bit ADC
const int REFERENCE_VOLTAGE_PIN = A1; // PC1   input   10-bit ADC
const int BOARD_POWER_PIN = 6;        // PD6   output  Digital: LOW = power off, HIGH = power on
const int BOARD_POWER_ON = HIGH;      
const int BOARD_POWER_OFF = LOW;      

// Sound                              
const int BUZZER_PIN = 10;            // PB2   output  PWM generated by MCU's built-in PWM capabillity
const int BUZZER_ON = 128;            
const int BUZZER_OFF = 0;             

// Lights                             
const int BATTERY_LED_LOW_PIN = A0;   // PC0   output  Digital: LOW = on, HIGH = off
const int BATTERY_LED_MED_PIN = 15;   // PB7   output  Digital: LOW = on, HIGH = off
const int BATTERY_LED_HIGH_PIN = A2;  // PC2   output  Digital: LOW = on, HIGH = off
const int CHARGING_LED_PIN = A3;      // PC3   output  Digital: LOW = on, HIGH = off
const int FAN_LOW_LED_PIN = A4;       // PC4   output  Digital: LOW = on, HIGH = off
const int FAN_MED_LED_PIN = A5;       // PC5   output  Digital: LOW = on, HIGH = off
const int FAN_HIGH_LED_PIN = 2;       // PD2   output  Digital: LOW = on, HIGH = off
const int LED_ON = LOW;               
const int LED_OFF = HIGH;             
                                      
// Serial                             
const int SERIAL_RX_PIN = 0;          // PD0   input   Only on development machines
const int SERIAL_TX_PIN = 1;          // PD1   output  Only on development machines

// For more details on pins, see this spreadsheet https://docs.google.com/spreadsheets/d/1jWqp-4zenKUAKNBiP8r8MMyYubxCdtR4T9kdl3J_pWg

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Misc board-specific constants
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

const double AMPS_PER_CHARGE_FLOW_UNIT = .0065;
const float VOLTS_PER_VOLTAGE_UNIT = 0.0293255; // 0 to 1023 yields 0 to 30 volts
const double BATTERY_CAPACITY_COULOMBS = 25200 * 1.0; // TODO what is the appropriate fudge factor, probably 0.8

// The MCU's fuse bytes should be set as follows
//   low fuse byte 0x72
//   high fuse byte 0xDA
//   extended fuse byte 0xFF

class InterruptCallback {
public:
    virtual void callback() = 0;
};

class Hardware {
public:
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Basic Hardware access - covers for Arduino API functions.
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline void pinMode(uint8_t pin, uint8_t mode) { ::pinMode(pin, mode); }
    inline void digitalWrite(uint8_t pin, uint8_t val) { ::digitalWrite(pin, val); }
    inline int digitalRead(uint8_t pin) { return ::digitalRead(pin); }
    inline int analogRead(uint8_t pin) { return ::analogRead(pin); }
    inline void analogWrite(uint8_t pin, int val) { ::analogWrite(pin, val); }
    inline unsigned long millis(void) { return ::millis(); }
    inline unsigned long micros(void) { return ::micros(); }
    inline void delay(unsigned long ms) { ::delay(ms); }
    inline void delayMicroseconds(unsigned int us) { ::delayMicroseconds(us); }
    inline void wdt_enable(const uint8_t value) { ::wdt_enable(value); }
    inline void wdt_disable() { ::wdt_disable(); }
    inline void wdt_reset_() { wdt_reset(); } // wdt_reset is a macro so we can't use "::"

    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // Functions for controlling PAPR and MCU hardware
    //
    ////////////////////////////////////////////////////////////////////////////////////////////////////////
    void reset();
    int watchdogStartup(void);
    void setPowerOnButtonInterruptCallback(InterruptCallback*);
    void setFanRPMInterruptCallback(InterruptCallback*);
    void setup();
    void setPowerMode(PowerMode mode);
    PowerMode getPowerMode() { return powerMode; }
    void handleInterrupt();
    double readVoltage(); // returns volts in the range 0 to 30
    double readCurrent(); // returns amperes in the range -6 to +6, positive when charging, negative when discharging

    // A note about the MCU clock: in low power mode, the MCU only receives 2.5 volts power,
    // which means we have to run it at a reduced clock speed. We use 1 MHz instead of the normal 8 MHz.
    // At this reduced speed, the delay() and millis() functions are 8x slower, and there may be other things
    // that don't work right. To avoid problems, we confine reduced speed mode to 2 small places in the code:
    // - when the power first comes on. (Because CLKDIV8 in the 328p low fuse byte causes the MCU to start up at 1 MHz).
    // - when we nap()

    static Hardware instance;

private:
    unsigned int powerOnButtonState;
    unsigned int fanRPMState;
    InterruptCallback* powerOnButtonInterruptCallback;
    InterruptCallback* fanRPMInterruptCallback;
    PowerMode powerMode;
    void updateInterruptHandling();
    Hardware();
    void configurePins();
    void initializeDevices();
    void setClockPrescaler(int prescalerSelect);
};